//现在需要一种压缩方法，把幂的连乘方案系统中得到的巨大整数范围
  // 压缩到可接受的数组范围中
//如何压缩呢?
  //有一种简单的方法就是使用取余操作符，它的作用是得到一个数被另一个数整除后的余数
  //当然这么做中间还是会有重复的，但是相比起数字相加，重复数量变得很少
//什么是冲突?
  //我们把可能发生下标重复的情况称为冲突
  //冲突不可避免，我们只能解决冲突
  //解决方案一般有两种：1、链地址法，2、开放地址法
  //链地址法:
    //每个数组单元中存储的不再是单个数据，而是一个链条
    //而这个链条是什么数据结构呢，常见的是数组或者链表
    //比如是链表，一旦发现重复，就将其插入到链表的首端或者末端
    //查询的时候，先根据哈希化后的下标值找到对应的位置，然后再在其链表查找数据
    //
    //数组还是链表呢?
      //数组或者链表在这里都可以，效率上也差不多
      //考虑到通常使用线性查找，这个时候就数组和链表差不多
      //这个选择实际还是要考虑到具体的业务需求
  //
  //开放地址法:
    //开放地址法的主要工作方式是寻找空白的单元格来添加重复的数据
    //然而这个探索空白单元格的方式一般又分成三种:
      //1、线性探测
        //这个方法不难理解，就是当前位置如果已经被占，就index+1直到有空的位置，然后插入数据
        //删除操作一个数据项的时候，不可以将这个位置下标的内容设为null，因为需要靠null来判别是否停止查询
        //所以有的时候会设为一个特殊项来进行判别删除，具体看业务逻辑而定
        //线性探测会产生聚集，从而影响哈希表的性能
      //2、二次探测
        //二次探测就是在线性探测的基础上进行优化，其优化主要是探测时的步长
        //比如从下标值x开始，x+1^2,x+2^2,x+3^2
        //但是这样步长不一的聚集只是比连续的数字稍好了一些
      //3、再次哈希
        //再次哈希就是又在二次探测的基础上进行优化
        //现在需要一种方法:产生一种依赖关键字的探测序列,而不是每个关键字都一样
        //再做一次哈希化，而这次的哈希化的结果作为步长
        //
        //二次哈希化需要具备如下特点
          //和第一个哈希函数不同(不然结果还是原来的位置)
          //不能输出为0(没有步长，算法进入死循环)
        //然而计算机专家已经设计出一种工作很好的哈希函数
        //stepSize = constant - (key % constant)
        //其中constant是质数,且小于数组的容量
        //例如:stepSize = 5 - (key % 5) ，满足需求，且结果不可能为0
  //在真实的开发过程中，使用链地址法的情况会更多一些
//
//哈希化:将大数字转化成数组范围内下标的过程，我们就称之为哈希化
//哈希函数:我们通常会将单词转成大数字，大数字在进行哈希化的代码实现放在一个函数中
//哈希表:最终将数据插入到这个数组，对整个结构进行封装，我们就称之为是一个哈希表